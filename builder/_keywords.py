import contextlib
import random
import re
from typing import List, Dict, Any

from _constants import logger
from _exceptions import GenerationError
from _predefined_variations import get_basic_variations, get_quality_variations, \
    get_style_variations, get_time_period_variations, \
    get_emotional_aesthetic_variations, get_meme_culture_variations, \
    get_professional_variations, get_camera_technique_variations, \
    get_focus_sharpness_variations, get_color_variations, get_lighting_variations, \
    get_location_variations, get_background_variations, get_size_format_variations, \
    get_texture_material_variations, get_condition_age_variations, \
    get_quantity_arrangement_variations, get_generic_quality_variations


class KeywordManagement:
    """
    Class responsible for managing keyword generation and preparation for dataset categories.
    This class handles AI-based keyword generation, keyword validation, and preparation
    of final keyword lists based on configuration settings.
    """

    def __init__(self, ai_model: str = "gpt4-mini", keyword_generation: str = "auto"):
        """
        Initializes the KeywordManagement instance.

        Args:
            ai_model (str): The AI model to use for keyword generation (e.g., "gpt4", "gpt4-mini").
            keyword_generation (str): The keyword generation mode ("auto", "enabled", "disabled").
        """
        self.ai_model = ai_model
        self.keyword_generation = keyword_generation

    def prepare_keywords(self, category_name: str, keywords: List[str]) -> Dict[
        str, Any]:
        """
        Prepares keywords for processing based on the configuration.
        This includes generating new keywords using an AI model if enabled and necessary.

        Args:
            category_name (str): The name of the category.
            keywords (List[str]): The initial list of keywords provided for the category.

        Returns:
            Dict[str, Any]: A dictionary containing:
                - 'keywords': The final list of keywords to be processed
                - 'original_keywords': The original keywords provided
                - 'generated_keywords': Any keywords generated by AI
                - 'generation_occurred': Boolean indicating if generation took place
        """
        # Record original keywords before any potential generation
        original_keywords = keywords.copy() if keywords else []
        generated_keywords = []
        generation_occurred = False

        if not keywords and self.keyword_generation in ["auto", "enabled"]:
            # No keywords provided and generation enabled
            generated_keywords = self.generate_keywords(category_name)
            keywords = generated_keywords
            generation_occurred = True
            logger.info(
                f"No keywords provided for category '{category_name}', generated {len(keywords)} keywords")

        elif not keywords and self.keyword_generation == "disabled":
            # No keywords and generation disabled, use category name as keyword
            keywords = [category_name]
            logger.info(
                f"No keywords provided for category '{category_name}' and generation disabled, using category name as keyword"
            )

        elif self.keyword_generation == "enabled" and keywords:
            # Keywords provided and asked to generate more
            generated_keywords = self.generate_keywords(category_name)
            # Add generated keywords to user-provided ones, avoiding duplicates
            original_count = len(keywords)
            keywords = list(set(keywords + generated_keywords))
            generation_occurred = True
            logger.info(
                f"Added {len(keywords) - original_count} generated keywords to {original_count} user-provided ones"
            )

        return {
            'keywords': keywords,
            'original_keywords': original_keywords,
            'generated_keywords': generated_keywords,
            'generation_occurred': generation_occurred
        }

    def generate_keywords(self, category: str) -> List[str]:
        """
        Generates related keywords for a given category using the G4F (GPT-4) API.
        This function attempts to generate diverse and high-quality search terms.

        Args:
            category (str): The category name for which to generate keywords.

        Returns:
            List[str]: A list of generated keywords related to the category.

        Raises:
            GenerationError: If keyword generation fails after retries.
        """
        try:
            # Import g4f here to avoid import issues if not available
            import g4f

            # Select the appropriate model
            provider = None  # Let g4f choose the best available provider
            model = g4f.models.gpt_4 if self.ai_model == "gpt4" else g4f.models.gpt_4o_mini

            # Create the prompt
            prompt = self._get_prompt(category)

            # Make the API call
            logger.info(f"Generating keywords for '{category}' using {self.ai_model}")
            response = g4f.ChatCompletion.create(
                model=model,
                provider=provider,
                messages=[{"role": "user", "content": prompt}]
            )

            # Extract keywords from response
            keywords = self._extract_keywords_from_response(response, category)

            logger.info(
                f"Generated {len(keywords)} keywords for '{category}' using {self.ai_model}")
            return keywords

        except Exception as e:
            logger.warning(
                f"Failed to generate keywords using {self.ai_model}: {str(e)}")
            raise GenerationError(
                f"Failed to generate keywords for '{category}' using {self.ai_model}: {e}") from e



    @staticmethod
    def _get_prompt(category: str) -> str:
        return f"""Generate 10-15 search keywords related to "{category}" that would be useful for
            finding diverse, high-quality images of this concept.

            Include variations that would work well for image search engines.

            Return ONLY the keywords as a Python list of strings, with no explanation or other text.
            Example format: ["keyword 1", "keyword 2", "keyword 3"]
            """

    def _extract_keywords_from_response(self, response: str, category: str) -> List[
        str]:
        """
        Extracts a list of keywords from the raw AI model response string.
        It attempts to parse a Python list structure first, then falls back to line-by-line extraction.

        Args:
            response (str): The raw response text received from the AI model.
            category (str): The original category name, which is always included in the returned list.

        Returns:
            List[str]: A cleaned and deduplicated list of extracted keywords.
        """
        try:
            # Try to find a list pattern in the response
            list_pattern = r'\[.*?\]'
            match = re.search(list_pattern, response, re.DOTALL)

            if match:
                # Found a list pattern, try to parse it
                list_str = match.group(0)
                with contextlib.suppress(Exception):
                    # Parse as Python list
                    keywords = eval(list_str)
                    if not (not isinstance(keywords, list) or not all(
                        isinstance(k, str) for k in keywords)):
                        return self._clean_and_deduplicate_keywords(keywords, category)

            # If we couldn't parse a proper list, try to extract keywords line by line
            lines = [line.strip() for line in response.split('\n')]
            keywords = []

            for line in lines:
                # Remove common list markers and quotes
                line = re.sub(r'^[-*â€¢"]', '', line).strip()
                line = re.sub(r'^[0-9]+\.', '', line).strip()
                line = line.strip('"\'')

                if line and not line.startswith('[') and not line.startswith(']'):
                    keywords.append(line)

            return self._clean_and_deduplicate_keywords(keywords, category)

        except Exception as e:
            logger.warning(f"Error extracting keywords from AI response: {str(e)}")
            # Return at least the category itself
            return [category]

    @staticmethod
    def _clean_and_deduplicate_keywords(keywords: List[str], category: str) -> List[
        str]:
        """
        Cleans and deduplicates a list of keywords.

        Args:
            keywords (List[str]): The list of keywords to clean.
            category (str): The original category name to ensure it's included.

        Returns:
            List[str]: A cleaned and deduplicated list of keywords.
        """
        # Remove duplicates and empty strings
        keywords = [k.strip() for k in keywords if k and k.strip()]
        keywords = list(
            dict.fromkeys(keywords))  # Remove duplicates while preserving order

        # Always include the category itself
        if category not in keywords:
            keywords.insert(0, category)

        return keywords


def validate_keywords(keywords: List[str]) -> List[str]:
    """
    Validates a list of keywords, removing invalid or problematic ones.

    Args:
        keywords (List[str]): The list of keywords to validate.

    Returns:
        List[str]: A list of validated keywords.
    """
    valid_keywords = []

    for keyword in keywords:
        # Remove leading/trailing whitespace
        keyword = keyword.strip()

        # Skip empty keywords
        if not keyword:
            continue

        # Skip keywords that are too short or too long
        if len(keyword) < 2 or len(keyword) > 100:
            logger.warning(f"Skipping keyword '{keyword}' - invalid length")
            continue

        # Skip keywords with invalid characters (basic validation)
        if re.search(r'[<>:"/\\|?*]', keyword):
            logger.warning(
                f"Skipping keyword '{keyword}' - contains invalid characters")
            continue

        valid_keywords.append(keyword)

    return valid_keywords


def keyword_stats(category_results: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
    """
    Generates statistics about keyword generation across all categories.

    Args:
        category_results (Dict[str, Dict[str, Any]]): Results from prepare_keywords for each category.

    Returns:
        Dict[str, Any]: Statistics about keyword generation.
    """
    stats = {
        'total_categories': len(category_results),
        'categories_with_generation': 0,
        'total_original_keywords': 0,
        'total_generated_keywords': 0,
        'total_final_keywords': 0,
        'generation_rate': 0.0
    }

    for category, result in category_results.items():
        stats['total_original_keywords'] += len(result['original_keywords'])
        stats['total_generated_keywords'] += len(result['generated_keywords'])
        stats['total_final_keywords'] += len(result['keywords'])

        if result['generation_occurred']:
            stats['categories_with_generation'] += 1

    if stats['total_categories'] > 0:
        stats['generation_rate'] = stats['categories_with_generation'] / stats[
            'total_categories']

    return stats


class AlternativeKeyTermGenerator:
    """
    Generates alternative search terms using predefined keywords from config.
    Intelligently combines multiple variations to create more effective search terms.
    """

    def __init__(self):
        """
        Initialize the generator with configuration keywords.
        """
        # Fall back to predefined
        self.generation_strategy = "predefined"

        self.category_functions = self._get_categories()

        # Extract clean terms from each category (remove {keyword} placeholder)
        self.clean_terms = self._extract_clean_terms()

        # AI components (will be initialized when AI is implemented)
        self._ai_enhancer = None
        if self.generation_strategy in ["ai-assisted", "ai-only"]:
            self._initialize_ai_components()

    @staticmethod
    def _get_categories() -> dict:
        return {
            'basic': get_basic_variations,
            'quality': get_quality_variations,
            'style': get_style_variations,
            'time_period': get_time_period_variations,
            'emotional_aesthetic': get_emotional_aesthetic_variations,
            'meme_culture': get_meme_culture_variations,
            'professional': get_professional_variations,
            'camera_technique': get_camera_technique_variations,
            'focus_sharpness': get_focus_sharpness_variations,
            'color': get_color_variations,
            'lighting': get_lighting_variations,
            'location': get_location_variations,
            'background': get_background_variations,
            'size_format': get_size_format_variations,
            'texture_material': get_texture_material_variations,
            'condition_age': get_condition_age_variations,
            'quantity_arrangement': get_quantity_arrangement_variations,
            'generic_quality': get_generic_quality_variations
        }

    def _extract_clean_terms(self) -> Dict[str, List[str]]:
        """Extract clean terms from each category by removing {keyword} placeholder"""
        clean_terms = {}

        for category, func in self.category_functions.items():
            variations = func()
            clean_terms[category] = []

            for variation in variations:
                # Remove {keyword} and clean up the remaining text
                clean_term = variation.replace("{keyword} ", "").replace("{keyword}",
                                                                         "").strip()
                if clean_term and clean_term not in clean_terms[category]:
                    clean_terms[category].append(clean_term)

        return clean_terms

    def _smart_combination_strategy_1(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 1: Quality + Style combination
        Example: "professional 4K realistic cat photo"
        """
        quality_term = random.choice(self.clean_terms['quality'])
        style_term = random.choice(self.clean_terms['style'])

        if retry_count <= 3:
            return f"{style_term} {quality_term} {keyword}"
        else:
            basic_term = random.choice(self.clean_terms['basic'])
            return f"{style_term} {quality_term} {keyword} {basic_term}"

    def _smart_combination_strategy_2(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 2: Multiple quality terms + emotional
        Example: "stunning high resolution 4K detailed cat"
        """
        quality_terms = random.sample(self.clean_terms['quality'],
                                      min(2, len(self.clean_terms['quality'])))
        emotional_term = random.choice(self.clean_terms['emotional_aesthetic'])

        if retry_count <= 5:
            return f"{emotional_term} {' '.join(quality_terms)} {keyword}"
        else:
            professional_term = random.choice(self.clean_terms['professional'])
            return f"{emotional_term} {professional_term} {' '.join(quality_terms)} {keyword}"

    def _smart_combination_strategy_3(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 3: Camera technique + lighting + style
        Example: "close up dramatic lighting realistic cat"
        """
        camera_term = random.choice(self.clean_terms['camera_technique'])
        lighting_term = random.choice(self.clean_terms['lighting'])
        style_term = random.choice(self.clean_terms['style'])

        return f"{camera_term} {lighting_term} {style_term} {keyword}"

    def _smart_combination_strategy_4(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 4: Background + color + quality
        Example: "white background colorful high quality cat photo"
        """
        background_term = random.choice(self.clean_terms['background'])
        color_term = random.choice(self.clean_terms['color'])
        quality_term = random.choice(self.clean_terms['quality'])
        basic_term = random.choice(self.clean_terms['basic'])

        return f"{background_term} {color_term} {quality_term} {keyword} {basic_term}"

    def _smart_combination_strategy_5(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 5: Complex multi-category combination
        Example: "professional studio lighting high resolution beautiful detailed cat photograph"
        """
        professional_term = random.choice(self.clean_terms['professional'])
        lighting_term = random.choice(self.clean_terms['lighting'])
        quality_term = random.choice(self.clean_terms['quality'])
        emotional_term = random.choice(self.clean_terms['emotional_aesthetic'])
        focus_term = random.choice(self.clean_terms['focus_sharpness'])
        basic_term = random.choice(self.clean_terms['basic'])

        return f"{professional_term} {lighting_term} {quality_term} {emotional_term} {focus_term} {keyword} {basic_term}"

    def _smart_combination_strategy_6(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 6: Location + time period + style
        Example: "indoor vintage artistic cat"
        """
        location_term = random.choice(self.clean_terms['location'])
        time_term = random.choice(self.clean_terms['time_period'])
        style_term = random.choice(self.clean_terms['style'])

        return f"{location_term} {time_term} {style_term} {keyword}"

    def _smart_combination_strategy_7(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 7: Size + texture + color
        Example: "large textured colorful cat"
        """
        size_term = random.choice(self.clean_terms['size_format'])
        texture_term = random.choice(self.clean_terms['texture_material'])
        color_term = random.choice(self.clean_terms['color'])

        return f"{size_term} {texture_term} {color_term} {keyword}"

    def _smart_combination_strategy_8(self, keyword: str, retry_count: int) -> str:
        """
        Strategy 8: Condition + arrangement + generic quality
        Example: "new organized excellent cat"
        """
        condition_term = random.choice(self.clean_terms['condition_age'])
        arrangement_term = random.choice(self.clean_terms['quantity_arrangement'])
        quality_term = random.choice(self.clean_terms['generic_quality'])

        return f"{condition_term} {arrangement_term} {quality_term} {keyword}"

    @staticmethod
    def _progressive_strategy_selection(retry_count: int) -> int:
        """
        Progressively select more complex strategies as retry count increases
        """
        if retry_count <= 2:
            return random.choice([1, 2])
        elif retry_count <= 4:
            return random.choice([1, 2, 3])
        elif retry_count <= 6:
            return random.choice([2, 3, 4])
        elif retry_count <= 8:
            return random.choice([3, 4, 5])
        elif retry_count <= 10:
            return random.choice([4, 5, 6])
        elif retry_count <= 12:
            return random.choice([5, 6, 7])
        else:
            return random.choice([6, 7, 8])

    def _initialize_ai_components(self):
        """
        Initialize AI components for AI-assisted generation.

        This will be implemented when AI integration is ready.
        For now, it's a placeholder that does nothing.
        """
        try:
            from _ai_keyword_integration import AIKeywordEnhancer
            self._ai_enhancer = AIKeywordEnhancer(self.ai_model)
            logger.info(f"AI components initialized with model: {self.ai_model}")
        except ImportError:
            logger.warning("AI integration module not available")
            self._ai_enhancer = None
        except Exception as e:
            logger.warning(f"Failed to initialize AI components: {e}")
            self._ai_enhancer = None

    # noinspection PyArgumentList
    def generate(self, keyword: str, retry_count: int = 0) -> List[str]:
        """
        Generate alternative search terms using the configured strategy.

        Args:
            keyword: The original search keyword
            retry_count: Current retry count (influences strategy complexity)

        Returns:
            List of intelligently generated alternative search terms
        """
        if not keyword:
            return []

        # Route to appropriate generation method based on strategy
        if self.generation_strategy == "predefined":
            return self._generate_with_predefined(keyword, retry_count)
        elif self.generation_strategy == "ai-assisted":
            return self._generate_with_ai_assisted(keyword, retry_count)
        elif self.generation_strategy == "ai-only":
            return self._generate_with_ai_only(keyword, retry_count)
        else:
            # Fallback to predefined
            logger.warning(f"Unknown strategy '{self.generation_strategy}', using predefined")
            return self._generate_with_predefined(keyword, retry_count)

    def _generate_with_predefined(self, keyword: str, retry_count: int) -> List[str]:
        """
        Generate variations using predefined keyword combinations (current implementation).

        Args:
            keyword: The original search keyword
            retry_count: Current retry count (influences strategy complexity)

        Returns:
            List of keyword variations
        """
        # Always start with the original keyword
        alternatives = [keyword]

        # Generate variations using different smart strategies
        strategies = self._get_strategies()

        # Generate multiple alternatives using different strategies
        num_alternatives = min(15,
                               3 + retry_count)  # More alternatives for higher retry counts

        for i in range(num_alternatives):
            strategy_num = self._progressive_strategy_selection(retry_count + i)
            strategy_func = strategies[strategy_num]

            try:
                # noinspection PyArgumentList
                alternative = strategy_func(keyword, retry_count + i)
                if alternative and alternative not in alternatives:
                    alternatives.append(alternative)
            except Exception as e:
                logger.warning(f"Strategy {strategy_num} failed: {e}")
                # Fallback to simple combination
                quality_term = random.choice(self.clean_terms['quality'])
                alternatives.append(f"{quality_term} {keyword}")

        # Add some simple fallbacks if we don't have enough alternatives
        if len(alternatives) < 8:
            self._generate_simple_fallback(keyword, alternatives)

        # Shuffle to add randomness while keeping original keyword first
        alternatives_to_shuffle = alternatives[1:]
        random.shuffle(alternatives_to_shuffle)

        return [alternatives[0]] + alternatives_to_shuffle

    def _generate_with_ai_assisted(self, keyword: str, retry_count: int) -> List[str]:
        """
        Generate variations with AI assistance (FUTURE IMPLEMENTATION).

        This method will:
        1. Use AI to select the best predefined variation function for the keyword
        2. Get variations from selected predefined categories
        3. Use AI to generate additional complementary variations
        4. Combine predefined + AI-generated keywords intelligently

        Args:
            keyword: The original search keyword
            retry_count: Current retry count

        Returns:
            List of keyword variations (predefined + AI-generated)

        TODO: Implement AI integration
        - Use AIKeywordEnhancer.enhance_full_ai_assisted()
        - Pass predefined categories to AI for selection
        - Generate additional variations with AI
        - Merge and deduplicate results
        - Handle AI failures gracefully
        """
        logger.warning(
            f"AI-assisted generation called for '{keyword}' but not implemented. "
            "Falling back to predefined variations."
        )

        # Future implementation:
        # if self._ai_enhancer:
        #     try:
        #         return self._ai_enhancer.enhance_full_ai_assisted(
        #             keyword=keyword,
        #             predefined_categories=self.clean_terms,
        #             retry_count=retry_count,
        #             additional_count=5
        #         )
        #     except NotImplementedError:
        #         logger.warning("AI enhancement not yet implemented, using predefined")
        #     except Exception as e:
        #         logger.error(f"AI enhancement failed: {e}, using predefined")

        # For now, fall back to predefined implementation
        return self._generate_with_predefined(keyword, retry_count)

    def _generate_with_ai_only(self, keyword: str, retry_count: int) -> List[str]:
        """
        Generate variations using pure AI (FUTURE IMPLEMENTATION).

        This method will use AI exclusively to generate keyword variations,
        without relying on predefined categories.

        Args:
            keyword: The original search keyword
            retry_count: Current retry count

        Returns:
            List of AI-generated keyword variations

        TODO: Implement pure AI generation
        - Use AIKeywordGenerator.generate_progressive_variations()
        - Generate diverse variations based on retry count
        - Validate and clean AI-generated keywords
        - Ensure minimum quality and relevance
        """
        logger.warning(
            f"AI-only generation called for '{keyword}' but not implemented. "
            "Falling back to predefined variations."
        )

        # Future implementation:
        # if self._ai_enhancer:
        #     try:
        #         return self._ai_enhancer.generator.generate_progressive_variations(
        #             keyword=keyword,
        #             retry_count=retry_count
        #         )
        #     except NotImplementedError:
        #         logger.warning("AI-only generation not yet implemented, using predefined")
        #     except Exception as e:
        #         logger.error(f"AI generation failed: {e}, using predefined")

        # For now, fall back to predefined implementation
        return self._generate_with_predefined(keyword, retry_count)

    def _generate_simple_fallback(self, keyword: str, alternatives: list) -> None:
        simple_combinations = [
            f"{keyword} {random.choice(self.clean_terms['quality'])}",
            f"{random.choice(self.clean_terms['style'])} {keyword}",
            f"{keyword} {random.choice(self.clean_terms['basic'])}",
            f"{random.choice(self.clean_terms['emotional_aesthetic'])} {keyword}",
            f"{random.choice(self.clean_terms['professional'])} {keyword}",
        ]

        for combo in simple_combinations:
            if combo not in alternatives:
                alternatives.append(combo)
                if len(alternatives) >= 15:
                    break

    def _get_strategies(self):
        return {
            1: self._smart_combination_strategy_1,
            2: self._smart_combination_strategy_2,
            3: self._smart_combination_strategy_3,
            4: self._smart_combination_strategy_4,
            5: self._smart_combination_strategy_5,
            6: self._smart_combination_strategy_6,
            7: self._smart_combination_strategy_7,
            8: self._smart_combination_strategy_8
        }

    def next_term(self, keyword: str, retry_count: int) -> str:
        """
        Get the next search term for a specific retry attempt.

        Args:
            keyword: Original keyword
            retry_count: Current retry count

        Returns:
            Next search term to try
        """
        alternatives = self.generate(keyword, retry_count)

        # Return the term at the retry index, or cycle through if we exceed the list
        if retry_count < len(alternatives):
            return alternatives[retry_count]
        else:
            # Cycle through alternatives for very high retry counts
            return alternatives[retry_count % len(alternatives)]

    def _select_best_category_with_ai(self, keyword: str) -> str:
        """
        Use AI to select the best predefined variation category for a keyword.

        FUTURE IMPLEMENTATION: This will analyze the keyword and determine which
        predefined category (professional, style, quality, etc.) best matches
        the user's intent.

        Args:
            keyword: User's input keyword

        Returns:
            Best matching category name

        TODO: Implement AI-based category selection
        Example approach:
        - Prompt: "Given the keyword '{keyword}', which category best describes it:
          professional, artistic/style, quality-focused, emotional/aesthetic,
          technical/camera, location-based, or generic?"
        - Parse AI response to get category name
        - Return corresponding category from self.category_functions
        """
        raise NotImplementedError("AI category selection not yet implemented")

    def _generate_additional_with_ai(self, keyword: str, count: int = 5) -> List[str]:
        """
        Use AI to generate additional keyword variations beyond predefined ones.

        FUTURE IMPLEMENTATION: This will use AI to create contextually relevant
        keyword variations that complement the predefined variations.

        Args:
            keyword: Base keyword
            count: Number of additional variations to generate

        Returns:
            List of AI-generated keyword variations

        TODO: Implement AI-based variation generation
        Example approach:
        - Prompt: "Generate {count} diverse search keyword variations for '{keyword}'
          that would help find high-quality images. Focus on terms that complement
          these categories: quality, style, lighting, composition."
        - Parse AI response to extract keywords
        - Validate and clean generated keywords
        - Return list of variations
        """
        raise NotImplementedError("AI variation generation not yet implemented")
